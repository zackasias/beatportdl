package main

import (
	"bufio"
	"errors"
	"fmt"
	"os"
	"regexp"
	"strconv"
	"strings"
	"unspok3n/beatportdl/config"
	"unspok3n/beatportdl/internal/beatport"
)

// Setup loads the first valid config YAML and returns the AppConfig.
func Setup() (cfg *config.AppConfig, err error) {
	configFiles, err := FindConfigFiles()
	if err != nil || len(configFiles) == 0 {
		return nil, fmt.Errorf("no config files found: %w", err)
	}

	var loginSuccess bool
	for _, cfgPath := range configFiles {
		parsedConfig, err := config.Parse(cfgPath)
		if err != nil {
			fmt.Println("Failed to parse", cfgPath, ":", err)
			continue
		}

		auth := beatport.NewAuth(parsedConfig.Username, parsedConfig.Password, "")
		bp := beatport.New(beatport.StoreBeatport, parsedConfig.Proxy, auth)
		bs := beatport.New(beatport.StoreBeatsource, parsedConfig.Proxy, auth)

		// Attempt login
		if err := auth.Init(bp); err != nil {
			fmt.Println("Login failed with", cfgPath, ", trying next...")
			continue
		}

		fmt.Println("Login successful with", cfgPath)
		// Set global cfg and Beatport instances in main
		cfg = parsedConfig
		loginSuccess = true
		break
	}

	if !loginSuccess {
		return nil, errors.New("all config files failed to login")
	}

	return cfg, nil
}

func (app *application) mainPrompt() {
	fmt.Print("Enter url or search query: ")
	input := GetLine()
	if strings.HasPrefix(input, "https://www.beatport.com") || strings.HasPrefix(input, "https://www.beatsource.com") {
		app.urls = append(app.urls, input)
	} else {
		app.search(input)
	}
}

func (app *application) search(input string) {
	var storeTag string
	var inst *beatport.Beatport
	storeTag, input = extractStoreTag(input)
	switch storeTag {
	default:
		inst = app.bp
	case "beatsource":
		inst = app.bs
	}

	results, err := inst.Search(input)
	if err != nil {
		app.FatalError("beatport", err)
	}
	trackResultsLen := len(results.Tracks)
	releasesResultsLen := len(results.Releases)

	if trackResultsLen+releasesResultsLen == 0 {
		fmt.Println("No results found")
		return
	}

	fmt.Println("Search results:")
	fmt.Println("[ Tracks ]")
	for i, track := range results.Tracks {
		fmt.Printf(
			"%2d. %s - %s (%s) [%s]\n", i+1,
			track.Artists.Display(
				app.config.ArtistsLimit,
				app.config.ArtistsShortForm,
			),
			track.Name.String(),
			track.MixName.String(),
			track.Length,
		)
	}
	fmt.Println("\n[ Releases ]")
	indexOffset := trackResultsLen + 1
	for i, release := range results.Releases {
		fmt.Printf(
			"%2d. %s - %s [%s]\n", i+indexOffset,
			release.Artists.Display(
				app.config.ArtistsLimit,
				app.config.ArtistsShortForm,
			),
			release.Name.String(),
			release.Label.Name,
		)
	}
	fmt.Print("Enter the result number(s): ")
	input = GetLine()
	requestedResults := strings.Split(input, " ")
	for _, result := range requestedResults {
		resultInt, err := strconv.Atoi(result)
		if err != nil {
			fmt.Printf("invalid result number: %s\n", result)
			continue
		}

		if resultInt > releasesResultsLen+trackResultsLen || resultInt == 0 {
			fmt.Printf("invalid result number: %d\n", resultInt)
			continue
		}

		if resultInt >= indexOffset {
			app.urls = append(app.urls, results.Releases[resultInt-indexOffset].URL)
		} else {
			app.urls = append(app.urls, results.Tracks[resultInt-1].URL)
		}
	}
}

func extractStoreTag(query string) (store, trimmedQuery string) {
	re := regexp.MustCompile(`@\w+`)
	matches := re.FindAllString(query, -1)
	if len(matches) > 0 {
		store = strings.TrimPrefix(matches[0], "@")
		trimmedQuery = re.ReplaceAllString(query, "")
		trimmedQuery = strings.TrimSpace(trimmedQuery)
	} else {
		trimmedQuery = query
	}
	return store, trimmedQuery
}

func (app *application) parseTextFile(path string) {
	file, err := os.Open(path)
	if err != nil {
		app.FatalError("read input text file", err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		app.urls = append(app.urls, scanner.Text())
	}
}

var (
	ErrUnsupportedLinkType  = errors.New("unsupported link type")
	ErrUnsupportedLinkStore = errors.New("unsupported link store")
)
